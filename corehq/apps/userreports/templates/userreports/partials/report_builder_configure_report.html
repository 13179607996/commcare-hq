{% extends "userreports/base_report_builder.html" %}
{% load i18n %}
{% load hq_shared_tags %}

{% block js %}{{ block.super }}
    <script src="{% new_static 'style/js/bootstrap3/main.js' %}"></script>
    <script src="{% new_static 'app_manager/js/case-knockout-bindings.js' %}"></script>
{% endblock %}

{% block page_title %}
    {% if not editing_existing_report %}
    {% trans "Step 2 of 2" %} -
    {% endif %}
    {% trans "Configure Report Settings" %}
{% endblock page_title %}

{% block js-inline %}{{ block.super }}
    <script type="text/javascript">

        var formatOptions = ["Choice", "Date"];
        var defaultCalculationOptions = ["Count per Choice", "Sum", "Average"];
        var nonNumericPropertyCalculationOptions = ["Count per Choice"];
        var propertyOptions = {{ property_options|JSON }};
        var isNonNumericMap = propertyOptions.reduce(function(map, option) {
            map[option.id] = option.is_non_numeric;
            return map;
        }, {});
        var optionsContainQuestions = _.any(propertyOptions, function (o) {
            return o.type == 'question';
        });
        if (optionsContainQuestions) {
            // Munge the property_options into the form expected by the questionsSelect binding.
            propertyOptions = _.compact(_.map(propertyOptions, function (o) {
                if (o.type === 'question') {
                    return o.source;
                } else if (o.type == 'meta') {
                    return {
                        value: o.source[0],
                        label: o.text,
                        type: o.type
                    }
                }
            }));
        }


        var getOrDefault = function(options, key, default_) {
            if (options[key] === undefined) {
                return default_
            } else {
                return options[key]
            }
        };

        /**
         * Knockout view model representing a row in the filter property list
         * @constructor
         */
        var PropertyListItem = function() {
            var self = this;

            this.property = ko.observable("");

            // True if the selected property is known to contain non numeric
            // data. This would be true for numeric form questions, false
            // for text questions and hidden value questions, and false for case
            // properties (because we don't know what type of data they might
            // contain)
            this.propertyIsNonNumeric = ko.pureComputed(function(){
                return isNonNumericMap[self.property()];
            });

            // True if the property exists in the current version of the app
            this.existsInCurrentVersion = ko.observable(true);

            // The header for the column or filter in the report
            this.displayText = ko.observable("");

            // True if the display text has been modified by the user at least once
            this.displayTextModifiedByUser = ko.observable(false);

            // True if the display text should be updated when the property changes
            this.inheritDisplayText = ko.observable(!Boolean(this.displayText()));
            this.property.subscribe(function(newValue) {
                if (self.inheritDisplayText()){
                    self.displayText(newValue);
                }
            });
            this.displayText.subscribe(function(value){
                if (!value) {
                    // If the display text has been cleared, go back to inherting
                    // it from the property
                    self.inheritDisplayText(true);
                }
            });

            // A proxy for displayText that will let us know when displayText
            // has been modified by the user (by updating inheritDisplayText).
            // This is useful because sometimes the displayText is changed
            // programatically when the user changes this.property.
            this.inputBoundDisplayText = ko.computed({
                read: function() {
                    return self.displayText();
                },
                write: function(value) {
                    // User has made changes to display text
                    self.inheritDisplayText(false);
                    self.displayTextModifiedByUser(true);
                    self.displayText(value);
                },
                owner: this
            });

            this.displayTextIsValid = ko.pureComputed(function(){
                // Blank display text is not allowed
                return Boolean(self.displayText());
            });
            this.showDisplayTextError = ko.pureComputed(function(){
                // This should also return true if the user has tried to submit the form
                return !self.displayTextIsValid() && (self.displayTextModifiedByUser() || self.showWarnings());
            });

            // The format of the filter. This field is not used if the
            // PropertyListItem is representing columns
            this.format = ko.observable("");
            // The aggregation type for this column. This field is not used if
            // the PropertyListItem represents columns in a non-aggregated report
            // or a filter
            this.calculation = ko.observable("Count per Choice");
            this.calculationOptions = ko.pureComputed(function(){
                if (self.propertyIsNonNumeric()) {
                    return nonNumericPropertyCalculationOptions;
                }
                return defaultCalculationOptions;
            });
            // If this PropertyListItem represents a property that no longer
            // exists in the app, then dataSourceField will be the name of the
            // property that no longer exists
            this.dataSourceField = ko.observable("");
            this.isEditable = ko.pureComputed(function(){
                return !self.existsInCurrentVersion();
            });

            // True if validation messages should be shown on any and all fields
            this.showWarnings = ko.observable(false);
            this.isValid = ko.computed(function(){
                return Boolean(self.property() && self.existsInCurrentVersion() && self.displayText());
            });
        };
        PropertyListItem.wrap = function(o){
            var i = new PropertyListItem();
            i.existsInCurrentVersion(o.exists_in_current_version);
            i.property(getOrDefault(o, 'property', ""));
            i.dataSourceField(getOrDefault(o, 'data_source_field', null));
            i.displayText(o.display_text);
            i.calculation(o.calculation);
            i.format(o.format);
            return i;
        };
        /**
         * Return a "plain" javascript object representing this view model
         * suitable for sending to the server.
         */
        PropertyListItem.prototype.toJS = function () {
            return {
                property: this.property(),
                display_text: this.displayText(),
                format: this.format(),
                calculation: this.calculation()
            };
        };
        /**
         *  Return True if the item is valid, and start showing warnings if
         *  we weren't already.
         */
        PropertyListItem.prototype.validate = function() {
            this.showWarnings(true);
            return this.isValid();
        };


        /**
         * Knockout view model controlling the filter property list.
         */
        var propertyList = function(options) {
            var self = this;
            options = options || {};

            this.buttonText = getOrDefault(options, 'buttonText', 'Add property');
            // True if at least one column is required.
            this.requireColumns = getOrDefault(options, 'requireColumns', false);
            this.requireColumnsText = getOrDefault(options, 'requireColumnsText', "Please select at least one property");
            // This function will be called if a user tries to submit the form with no columns.
            this.noColumnsValidationCallback = getOrDefault(options, 'noColumnsValidationCallback', null);
            this.propertyHelpText = getOrDefault(options, 'propertyHelpText', null);
            this.displayHelpText = getOrDefault(options, 'displayHelpText', null);
            this.formatHelpText = getOrDefault(options, 'formatHelpText', null);
            this.calcHelpText = getOrDefault(options, 'calcHelpText', null);
            this.analyticsAction = getOrDefault(options, 'analyticsAction', null);
            this.analyticsLabel = getOrDefault(options, 'analyticsLabel', '{{ report_type }}');

            this.hasFormatCol = ko.observable(getOrDefault(options, 'hasFormatCol', true));
            this.hasCalculationCol = ko.observable(getOrDefault(options, 'hasCalculationCol', false));

            this.columns = ko.observableArray(getOrDefault(options, 'initialCols', []));
            this.serializedProperties = ko.computed(function(){
                return JSON.stringify(
                    _.map(self.columns(), function(c){return c.toJS()})
                );
            });
            this.showWarnings = ko.observable(false);
            this.validate = function(){
                self.showWarnings(true);
                var columnsValid = !_.contains(
                    _.map(
                        self.columns(),
                        function(c){return c.validate()}
                    ),
                    false
                );
                var columnLengthValid = !(self.requireColumns && !self.columns().length);
                if (self.noColumnsValidationCallback && !columnLengthValid){
                    self.noColumnsValidationCallback();
                }
                return columnsValid && columnLengthValid;
            };
            this.buttonHandler = function(){
                this.columns.push(new PropertyListItem());
                if (!_.isEmpty(this.analyticsAction) && !_.isEmpty(this.analyticsLabel)){
                    window.analytics.usage("Report Builder", this.analyticsAction, this.analyticsLabel);
                    window.analytics.workflow("Clicked " + this.analyticsAction + " in Report Builder");
                }
            }
        };

        var configForm = function(){
            var self = this;
            var initialFilters = _.map({{ initial_filters|JSON }}, function(i){
                return PropertyListItem.wrap(i);
            });
            var initialColumns = _.map({{ initial_columns|JSON }}, function(i){
                return PropertyListItem.wrap(i);
            });
            // TODO: Pass help texts from template so that they can be translated.
            this.filtersList = new propertyList({
                hasFormatCol: {% if form.source_type == "case" %}true{% else %}false{% endif %},
                hasCalculationCol: false,
                initialCols: initialFilters,
                buttonText: 'Add Filter',
                analyticsAction: 'Add Filter',
                propertyHelpText: '{{ filter_property_help_text|escapejs}}',
                displayHelpText: '{{ filter_display_help_text|escapejs }}',
                formatHelpText: '{{ filter_format_help_text|escapejs }}'
            });
            this.columnsList = new propertyList({
                hasFormatCol: false,
                hasCalculationCol: {% if report_type == "table" or report_type == "worker" %}true{% else %}false{% endif %},
                initialCols: initialColumns,
                buttonText: 'Add Column',
                analyticsAction: 'Add Column',
                calcHelpText: '{{ calculation_help_text|escapejs }}',
                requireColumns: {% if report_type != "chart"%}true{% else %}false{% endif %},
                requireColumnsText: "At least one column is required",
                noColumnsValidationCallback: function(){
                    window.analytics.usage(
                        'Report Builder',
                        'Click On Done (No Columns)',
                        '{{ report_type }}'
                    );
                }
            });
            this.submitHandler = function(formElement){
                var isValid = true;
                isValid = self.filtersList.validate() && isValid;
                isValid = self.columnsList.validate() && isValid;
                if (!isValid){
                    alert('Invalid report configuration. Please fix the issues and try again.');
                    // The event handler that disables the button is triggered
                    // after this handler is invoked. Therefore, we use _.defer()
                    // to re-enable it immediately after the call stack clears.
                    _.defer(function(el){
                        $(el).find('.disable-on-submit').enableButton();
                    }, formElement);
                }
                return isValid;
            };
        };

        $("#report-config-form").koApplyBindings(new configForm());

        $(function () {
            {% for event in report_builder_events %}
                {# Track a usage events that were produced on the server #}
                window.analytics.usage.apply(this, {{event|JSON}});
            {% endfor %}
            window.analytics.trackUsageLink(
                "#delete-report-button", "Report Builder", "Delete a Repot", '{{ report_type }}'
            );
        });

    </script>
{% endblock %}
